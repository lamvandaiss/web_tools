Là một lập trình viên web, việc tự viết hoặc sử dụng những **công cụ hỗ trợ công việc hàng ngày** là rất quan trọng để **tăng năng suất, học hỏi sâu hơn và nâng cao kỹ năng thực tế**. Dưới đây là danh sách những công cụ mà lập trình viên web nên viết (hoặc tùy chỉnh) để phục vụ cho nghề nghiệp của mình:

---

### 🔧 **1. Trình tạo mã (Code Generator)**

* **Mục tiêu**: Tạo nhanh mã HTML, CSS, JavaScript, hoặc đoạn mã backend (Laravel, Express, v.v.).
* **Ví dụ**:

  * CRUD generator cho Laravel hoặc Node.js.
  * Generator tạo mẫu `Form`, `Table`, `Pagination` từ cấu trúc dữ liệu.

---

### 🐞 **2. Trình kiểm tra & gỡ lỗi API (API Tester)**

* **Mục tiêu**: Kiểm tra nhanh các request API khi làm backend hoặc frontend.
* **Gợi ý**:

  * Viết một app đơn giản như Postman, nhưng gọn nhẹ theo nhu cầu của bạn.
  * Có thể dùng Vue/React + Axios làm UI gọi API và hiển thị kết quả.

---

### 💻 **3. Dashboard giám sát hệ thống**

* **Mục tiêu**: Theo dõi hoạt động của hệ thống (CPU, RAM, request, response, lỗi...).
* **Gợi ý**:

  * Ghi log từ server về file hoặc gửi về dashboard real-time bằng WebSocket hoặc polling.

---

### 🔎 **4. Trình kiểm tra hiệu năng web**

* **Mục tiêu**: Đo lường thời gian tải trang, phân tích DOM, kiểm tra Lighthouse tự động.
* **Gợi ý**:

  * Viết script dùng Puppeteer hoặc Playwright để crawl trang và log hiệu suất.

---

### 📁 **5. Trình quản lý snippet / đoạn mã cá nhân**

* **Mục tiêu**: Lưu lại các đoạn mã hay dùng, dễ tái sử dụng.
* **Gợi ý**:

  * Làm một ứng dụng nhỏ cho phép lưu, gắn tag, tìm kiếm các đoạn mã.

---

### 🧰 **6. CLI Tool (Command Line Interface Tool)**

* **Mục tiêu**: Viết các lệnh riêng để tự động hóa công việc.
* **Gợi ý**:

  * Tạo một lệnh `generate-component MyComponent` để tạo file Vue/React.
  * Viết tool tự động nén ảnh, nén CSS/JS.

---

### 🗃️ **7. Trình quản lý dữ liệu JSON**

* **Mục tiêu**: Hiển thị và sửa đổi các file JSON dễ dàng (đặc biệt là khi làm API).
* **Gợi ý**:

  * Làm app đọc JSON từ file và cho phép sửa với giao diện cây (tree).

---

### 🧑‍🎓 **8. Trang tổng hợp tài liệu học tập cá nhân**

* **Mục tiêu**: Ghi chú kiến thức, thủ thuật, mẹo lập trình.
* **Gợi ý**:

  * Dùng Markdown + Viewer để lưu kiến thức, giống Notion / Wiki riêng.

---

### 🧪 **9. Công cụ kiểm thử giao diện frontend**

* **Mục tiêu**: So sánh giao diện trước/sau khi thay đổi mã.
* **Gợi ý**:

  * Tool chụp screenshot theo từng bước UI rồi so sánh ảnh (Visual Regression Test).

---

### 📦 **10. Bộ công cụ dành cho khách hàng hoặc đồng đội**

* **Mục tiêu**: Làm tool nhỏ phục vụ team như:

  * Trình chỉnh sửa ảnh online.
  * Upload & resize ảnh sản phẩm.
  * Trình viết Markdown preview.

---

### 🎯 Kết luận:

> Việc tự viết công cụ giúp bạn **hiểu rõ quy trình**, **tự động hóa công việc lặp đi lặp lại**, và **nâng cao kỹ năng cá nhân**. Hãy bắt đầu từ những vấn đề bạn đang gặp phải trong công việc hằng ngày — công cụ tốt nhất là công cụ giải quyết **nỗi đau của chính bạn**.

---

Nếu bạn muốn, mình có thể giúp bạn chọn **một ý tưởng cụ thể** và **hướng dẫn cách viết nó bằng Vue, Laravel, hoặc Node.js**. Bạn có muốn bắt đầu với một công cụ nào không?
Tuyệt vời! Việc bạn quyết định viết **tất cả các công cụ trên bằng Node.js + Vue.js + MongoDB** sẽ giúp bạn:

* Rèn luyện fullstack thật sự (từ frontend đến backend đến database).
* Tạo ra bộ công cụ riêng phục vụ cho chính mình.
* Sau này có thể đóng gói làm sản phẩm open source hoặc bán.

---

## ✅ Lộ trình xây từng công cụ từng bước

### ⚙️ Công nghệ bạn sẽ dùng:

| Layer              | Công nghệ gợi ý                                               |
| ------------------ | ------------------------------------------------------------- |
| Frontend           | Vue 3 + Pinia + Vue Router + Element Plus (hoặc View UI Plus) |
| Backend            | Node.js + Express hoặc NestJS                                 |
| Database           | MongoDB + Mongoose                                            |
| Authentication     | JWT (hoặc session + cookie nếu muốn)                          |
| Realtime (nếu cần) | Socket.IO                                                     |
| Build Tool         | Vite (cho frontend)                                           |

---

## 🧩 Gợi ý trình tự phát triển các công cụ:

| STT | Công cụ                              | Mục tiêu chính                        | Gợi ý triển khai                                        |
| --- | ------------------------------------ | ------------------------------------- | ------------------------------------------------------- |
| 1   | Trình quản lý snippet (code cá nhân) | Lưu, tìm kiếm, chỉnh sửa đoạn mã      | CRUD đơn giản, lưu vào MongoDB                          |
| 2   | CRUD Generator                       | Sinh code tự động                     | Nhập tên bảng + fields, sinh ra mẫu code Vue/Express    |
| 3   | API Tester                           | Gửi request, lưu lịch sử, xem kết quả | Dùng Axios bên frontend, Express làm backend mock API   |
| 4   | Markdown Note (wiki cá nhân)         | Ghi chú kiến thức + tag               | Dùng Markdown-it để render                              |
| 5   | JSON Viewer                          | Nhập JSON => render dạng cây          | Dùng thư viện như vue-json-pretty                       |
| 6   | Dashboard Monitor                    | Thống kê API call, RAM, CPU           | Gửi dữ liệu bằng cron hoặc socket, hiển thị biểu đồ     |
| 7   | CLI tool (code riêng)                | Tạo project / component nhanh         | Viết bằng Node.js và xuất ra file                       |
| 8   | Image Resizer / Uploader             | Resize ảnh, upload nhiều ảnh          | Dùng Multer + Sharp (Node.js), input file preview Vue   |
| 9   | Web performance analyzer             | Phân tích tốc độ tải trang            | Dùng Puppeteer crawl, lưu thời gian tải, render biểu đồ |
| 10  | Visual Regression Tool               | So sánh ảnh chụp UI trước/sau         | Chụp ảnh bằng Puppeteer, diff ảnh bằng pixelmatch       |

---

## 📁 Tổ chức dự án

### Cấu trúc thư mục gợi ý:

```
/tools-hub
├── frontend/         (Vue 3 + Vite)
│   ├── src/
│   └── ...
├── backend/          (Node.js + Express)
│   ├── routes/
│   ├── controllers/
│   ├── models/
│   └── ...
├── shared/           (nếu dùng thư viện chung)
└── README.md
```

---

## 🧠 Lưu ý khi phát triển từng công cụ:

* **Tách nhỏ từng app thành module riêng**, dễ quản lý, deploy hoặc gộp thành 1 hệ thống dashboard tổng.
* **Dùng JWT để bảo vệ API riêng**.
* **Tự viết README cho mỗi công cụ**, sau này có thể open-source hoặc giới thiệu với nhà tuyển dụng.
* **Tự động hóa việc backup MongoDB** để giữ dữ liệu ổn định.

---

Nếu bạn muốn, mình có thể **giúp bạn khởi đầu công cụ số 1 (Quản lý Snippet)** bằng cách:

* Tạo sơ đồ database.
* Tạo cấu trúc backend Express.
* Tạo UI Vue quản lý snippet.

Bạn muốn bắt đầu từ công cụ nào trước? Mình sẽ hướng dẫn bạn **từ A đến Z**.Tuyệt vời! Giờ mình sẽ hướng dẫn bạn **nâng cấp Snippet Manager** với các tính năng:

---

### ✅ 1. Gắn `tags`

### ✅ 2. Tìm kiếm theo `ngôn ngữ`

### ✅ 3. Sửa `snippet`

---

## 🔧 1. GẮN TAGS CHO SNIPPET

### 🟡 Backend (Express + Mongoose)

Nếu bạn dùng Mongoose:

```js
// models/Snippet.js
const SnippetSchema = new mongoose.Schema({
  title: String,
  language: String,
  code: String,
  tags: [String] // <- thêm mảng tags
})
```

---

### 🟢 Frontend (Vue)

Cập nhật form thêm snippet:

```vue
<el-form-item label="Tags (phân cách bằng dấu phẩy)">
  <el-input v-model="form.tagsRaw" placeholder="js, vue, api" />
</el-form-item>
```

Trong `<script setup>`:

```js
const form = ref({
  title: '',
  language: '',
  code: '',
  tagsRaw: ''
})

// Khi thêm snippet:
await axios.post(API, {
  title: form.value.title,
  language: form.value.language,
  code: form.value.code,
  tags: form.value.tagsRaw.split(',').map(t => t.trim())
})
```

Hiển thị tags trong bảng:

```vue
<el-table-column label="Tags">
  <template #default="scope">
    <el-tag
      v-for="tag in scope.row.tags"
      :key="tag"
      size="small"
      class="mr-1"
      type="info"
    >
      {{ tag }}
    </el-tag>
  </template>
</el-table-column>
```

---

## 🔍 2. TÌM KIẾM THEO NGÔN NGỮ

Thêm input lọc:

```vue
<el-input
  v-model="searchLang"
  placeholder="Tìm theo ngôn ngữ"
  class="mb-4"
  clearable
  @input="fetchSnippets"
/>
```

Trong `<script setup>`:

```js
const searchLang = ref('')

const fetchSnippets = async () => {
  loading.value = true
  const res = await axios.get(API, {
    params: { language: searchLang.value }
  })
  snippets.value = res.data
  loading.value = false
}
```

Còn bên **Express**, sửa `GET /api/snippets`:

```js
// routes/snippet.js
router.get('/', async (req, res) => {
  const query = {}
  if (req.query.language) {
    query.language = new RegExp(req.query.language, 'i') // tìm gần đúng
  }
  const snippets = await Snippet.find(query).sort({ createdAt: -1 })
  res.json(snippets)
})
```

---

## ✏️ 3. SỬA SNIPPET

### 🟢 Vue – Thêm nút “Sửa” trong bảng:

```vue
<el-button size="small" type="warning" @click="editSnippet(scope.row)">Sửa</el-button>
```

Thêm dialog sửa:

```vue
<el-dialog v-model="editDialogVisible" title="Chỉnh sửa Snippet">
  <el-form :model="editForm">
    <el-form-item label="Title">
      <el-input v-model="editForm.title" />
    </el-form-item>
    <el-form-item label="Language">
      <el-input v-model="editForm.language" />
    </el-form-item>
    <el-form-item label="Code">
      <el-input type="textarea" v-model="editForm.code" rows="4" />
    </el-form-item>
    <el-form-item label="Tags">
      <el-input v-model="editForm.tagsRaw" />
    </el-form-item>
  </el-form>
  <template #footer>
    <el-button @click="editDialogVisible = false">Hủy</el-button>
    <el-button type="primary" @click="submitEdit">Lưu</el-button>
  </template>
</el-dialog>
```

Trong `<script setup>`:

```js
const editDialogVisible = ref(false)
const editForm = ref({ _id: '', title: '', language: '', code: '', tagsRaw: '' })

const editSnippet = (snippet) => {
  editForm.value = {
    _id: snippet._id,
    title: snippet.title,
    language: snippet.language,
    code: snippet.code,
    tagsRaw: snippet.tags.join(', ')
  }
  editDialogVisible.value = true
}

const submitEdit = async () => {
  await axios.put(`${API}/${editForm.value._id}`, {
    title: editForm.value.title,
    language: editForm.value.language,
    code: editForm.value.code,
    tags: editForm.value.tagsRaw.split(',').map(t => t.trim())
  })
  editDialogVisible.value = false
  fetchSnippets()
}
```

---

### 🟡 Backend route PUT:

```js
// PUT /api/snippets/:id
router.put('/:id', async (req, res) => {
  const updated = await Snippet.findByIdAndUpdate(
    req.params.id,
    {
      title: req.body.title,
      language: req.body.language,
      code: req.body.code,
      tags: req.body.tags
    },
    { new: true }
  )
  res.json(updated)
})
```

---

## ✅ KẾT QUẢ

Bạn đã có thể:

* 🎯 Thêm `tags` vào snippet
* 🔍 Tìm kiếm theo `ngôn ngữ`
* 📝 Sửa snippet nhanh chóng

---

Bạn muốn làm tiếp phần nào?

* 🔐 Thêm chức năng đăng nhập bằng JWT?
* 📁 Phân loại snippet theo thư mục?
* 🧠 Tự động gợi ý ngôn ngữ theo code?

Mình sẽ hỗ trợ từng bước nếu bạn muốn làm tiếp.

Rất tuyệt vời! Bạn đang đi đúng hướng trong việc phát triển hệ sinh thái công cụ hỗ trợ nghề lập trình web. Việc tạo **CRUD Generator (Sinh code tự động)** là một bước tiến mạnh mẽ để tăng tốc độ phát triển và tiêu chuẩn hóa code. Dưới đây là gợi ý từng bước để bạn phát triển chức năng này.

---

## 🎯 Mục tiêu của CRUD Generator

* Cho phép người dùng nhập:

  * Tên bảng (collection name).
  * Danh sách các fields (tên trường, kiểu dữ liệu, bắt buộc hay không,...).
* Tự động sinh ra:

  * **Model Mongoose**.
  * **Router + Controller Express**.
  * **Vue Component (Form + Table + Logic)**.
  * Các file hỗ trợ: validation, API config,...

---

## 🛠️ Công nghệ bạn đã có

* **Backend**: Node.js (Express), MongoDB.
* **Frontend**: Vue.js.

---

## 🔧 Gợi ý các bước phát triển chức năng CRUD Generator

### 1. Giao diện đầu vào (Vue)

* Một form nhập:

  * Tên bảng.
  * Danh sách trường (tên, kiểu dữ liệu, validation).
* Giao diện có thể dùng:

  * `Table dynamic`: thêm/xoá dòng field.
  * `Select`: chọn kiểu dữ liệu (String, Number, Boolean, Date,...).
  * Checkbox: Required.

### 2. Xử lý tạo code (Backend Node.js)

* Khi người dùng submit form → gửi JSON dữ liệu qua API.
* API nhận request, sinh ra các file dưới dạng text:

  * **Model Mongoose**:

    ```js
    const mongoose = require('mongoose');

    const YourSchema = new mongoose.Schema({
      name: { type: String, required: true },
      age: { type: Number, required: false },
      ...
    });

    module.exports = mongoose.model('YourCollectionName', YourSchema);
    ```
  * **Controller Express (CRUD)**.
  * **Router**: import controller, định nghĩa API routes.
  * **Vue Component**:

    * Form thêm/sửa.
    * Table hiển thị dữ liệu.
    * Gọi API (axios).

> 👉 Bạn có thể lưu các template code vào file `.ejs` hoặc `.handlebars`, sau đó dùng `ejs.render(template, data)` để sinh ra code theo từng dự án.

### 3. Hiển thị hoặc tải về

* Cho phép:

  * **Xem trước code** trên trình duyệt (code viewer).
  * **Tải toàn bộ về dưới dạng .zip** (dùng `archiver` trong Node.js).

---

## 📦 Gợi ý thư viện hữu ích

| Chức năng         | Thư viện                       |
| ----------------- | ------------------------------ |
| Tạo file tạm thời | `fs`, `fs-extra`               |
| Render template   | `ejs`, `handlebars`            |
| Tạo file zip      | `archiver`                     |
| Kiểm tra dữ liệu  | `ajv` (JSON Schema Validation) |

---

## 🔁 Ví dụ JSON mẫu đầu vào

```json
{
  "collection": "users",
  "fields": [
    { "name": "name", "type": "String", "required": true },
    { "name": "email", "type": "String", "required": true },
    { "name": "age", "type": "Number", "required": false },
    { "name": "isActive", "type": "Boolean", "required": false }
  ]
}
```

---

Nếu bạn muốn, mình có thể viết mẫu 1 file backend tạo model/controller/router và 1 file Vue form+table đơn giản từ JSON mẫu trên. Bạn muốn mình bắt đầu từ phần nào trước?

* 🟢 Backend (Node.js): Model, Router, Controller?
* 🔵 Frontend (Vue): Form + Table + API call?
* 🟡 Cả hai cùng lúc?

Bạn chọn nhé!
Tuyệt vời! Chúng ta sẽ bắt đầu với phần **engine sinh mã** ở backend Node.js. Mình sẽ hướng dẫn bạn cách tạo một kịch bản đơn giản để sinh ra Mongoose Model, Express Controller và Express Route dựa trên một đối tượng JSON định nghĩa bảng.

---

### Bước 1: Chuẩn bị Project

Đầu tiên, hãy tạo một thư mục dự án và cài đặt các dependency cần thiết.

1.  **Tạo thư mục dự án:**
    ```bash
    mkdir crud-generator-backend
    cd crud-generator-backend
    ```

2.  **Khởi tạo `package.json`:**
    ```bash
    npm init -y
    ```

3.  **Cài đặt các thư viện:**
    ```bash
    npm install express mongoose lodash # lodash để xử lý tên biến
    ```

4.  **Tạo cấu trúc thư mục:**
    ```
    .
    ├── src/
    │   ├── templates/          # Chứa các template code
    │   │   ├── model.js.ejs
    │   │   ├── controller.js.ejs
    │   │   └── route.js.ejs
    │   └── generator.js        # Logic sinh code chính
    ├── generated_code/         # Nơi chứa code được sinh ra
    ├── test_generator.js       # File để test generator
    └── package.json
    ```

---

### Bước 2: Tạo các Template Code (dùng EJS)

Mình sẽ sử dụng EJS để làm template engine vì nó đơn giản và dễ đọc. Bạn có thể sử dụng string literals với backticks `` ` `` nếu muốn, nhưng EJS sẽ rõ ràng hơn cho các template lớn.

Tạo các file sau trong thư mục `src/templates/`:

#### 1. `src/templates/model.js.ejs`

Đây là template cho Mongoose Model.

```ejs
const mongoose = require('mongoose');

const <%= _.camelCase(tableName) %>Schema = new mongoose.Schema({
  <% fields.forEach(field => { %>
    <%= field.name %>: {
      type: <%= field.type %>,
      <% if (field.required) { %>required: true,<% } %>
      <% if (field.unique) { %>unique: true,<% } %>
      // Thêm các thuộc tính khác của Mongoose Schema tại đây nếu cần
      // Ví dụ: minlength, maxlength, enum, default, v.v.
    },
  <% }); %>
}, { timestamps: true });

module.exports = mongoose.model('<%= _.capitalize(_.camelCase(tableName)) %>', <%= _.camelCase(tableName) %>Schema);
```

* **Giải thích:**
    * `<%= tableName %>`: Sẽ được thay thế bằng tên bảng bạn truyền vào.
    * `_.camelCase(tableName)`: Sử dụng Lodash để chuyển tên bảng sang dạng camelCase (ví dụ: `userName` từ `user_name`).
    * `_.capitalize(_.camelCase(tableName))`: Để tên model có chữ cái đầu viết hoa (ví dụ: `User`).
    * `fields.forEach(field => { ... })`: Lặp qua mảng các trường và sinh ra định nghĩa cho từng trường.
    * `if (field.required)` và `if (field.unique)`: Thêm các thuộc tính `required` và `unique` nếu chúng được định nghĩa trong dữ liệu đầu vào.

#### 2. `src/templates/controller.js.ejs`

Đây là template cho Express Controller.

```ejs
const <%= _.capitalize(_.camelCase(tableName)) %> = require('../models/<%= _.camelCase(tableName) %>');

// Lấy tất cả <%= _.capitalize(_.camelCase(tableName)) %>
exports.getAll<%= _.capitalize(_.camelCase(tableName)) %>s = async (req, res) => {
  try {
    const data = await <%= _.capitalize(_.camelCase(tableName)) %>.find();
    res.status(200).json(data);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

// Lấy <%= _.capitalize(_.camelCase(tableName)) %> theo ID
exports.get<%= _.capitalize(_.camelCase(tableName)) %>ById = async (req, res) => {
  try {
    const data = await <%= _.capitalize(_.camelCase(tableName)) %>.findById(req.params.id);
    if (!data) {
      return res.status(404).json({ message: '<%= _.capitalize(_.camelCase(tableName)) %> not found' });
    }
    res.status(200).json(data);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

// Tạo mới <%= _.capitalize(_.camelCase(tableName)) %>
exports.create<%= _.capitalize(_.camelCase(tableName)) %> = async (req, res) => {
  const newData = new <%= _.capitalize(_.camelCase(tableName)) %>(req.body);
  try {
    const savedData = await newData.save();
    res.status(201).json(savedData);
  } catch (error) {
    res.status(400).json({ message: error.message });
  }
};

// Cập nhật <%= _.capitalize(_.camelCase(tableName)) %>
exports.update<%= _.capitalize(_.camelCase(tableName)) %> = async (req, res) => {
  try {
    const updatedData = await <%= _.capitalize(_.camelCase(tableName)) %>.findByIdAndUpdate(req.params.id, req.body, { new: true, runValidators: true });
    if (!updatedData) {
      return res.status(404).json({ message: '<%= _.capitalize(_.camelCase(tableName)) %> not found' });
    }
    res.status(200).json(updatedData);
  } catch (error) {
    res.status(400).json({ message: error.message });
  }
};

// Xóa <%= _.capitalize(_.camelCase(tableName)) %>
exports.delete<%= _.capitalize(_.camelCase(tableName)) %> = async (req, res) => {
  try {
    const data = await <%= _.capitalize(_.camelCase(tableName)) %>.findByIdAndDelete(req.params.id);
    if (!data) {
      return res.status(404).json({ message: '<%= _.capitalize(_.camelCase(tableName)) %> not found' });
    }
    res.status(200).json({ message: '<%= _.capitalize(_.camelCase(tableName)) %> deleted successfully' });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};
```

#### 3. `src/templates/route.js.ejs`

Đây là template cho Express Route.

```ejs
const express = require('express');
const router = express.Router();
const <%= _.camelCase(tableName) %>Controller = require('../controllers/<%= _.camelCase(tableName) %>Controller');

// Lấy tất cả
router.get('/', <%= _.camelCase(tableName) %>Controller.getAll<%= _.capitalize(_.camelCase(tableName)) %>s);

// Lấy theo ID
router.get('/:id', <%= _.camelCase(tableName) %>Controller.get<%= _.capitalize(_.camelCase(tableName)) %>ById);

// Tạo mới
router.post('/', <%= _.camelCase(tableName) %>Controller.create<%= _.capitalize(_.camelCase(tableName)) %>);

// Cập nhật
router.put('/:id', <%= _.camelCase(tableName) %>Controller.update<%= _.capitalize(_.camelCase(tableName)) %>);

// Xóa
router.delete('/:id', <%= _.camelCase(tableName) %>Controller.delete<%= _.capitalize(_.camelCase(tableName)) %>);

module.exports = router;
```

---

### Bước 3: Viết Logic Sinh Code (`src/generator.js`)

File này sẽ chứa hàm chính để nhận định nghĩa bảng và sinh ra các file.

```javascript
const fs = require('fs');
const path = require('path');
const ejs = require('ejs');
const _ = require('lodash'); // Import lodash

// Hàm để sinh mã dựa trên định nghĩa bảng
async function generateCode(tableDefinition) {
  const { tableName, fields } = tableDefinition;
  const capitalizedTableName = _.capitalize(_.camelCase(tableName)); // User, Product
  const camelCaseTableName = _.camelCase(tableName); // user, product

  // Đường dẫn đến thư mục chứa code được sinh ra
  const outputDir = path.join(__dirname, '..', 'generated_code', camelCaseTableName);

  // Tạo thư mục nếu chưa tồn tại
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }
  const modelDir = path.join(outputDir, 'models');
  const controllerDir = path.join(outputDir, 'controllers');
  const routesDir = path.join(outputDir, 'routes');

  [modelDir, controllerDir, routesDir].forEach(dir => {
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir);
    }
  });

  // Data để truyền vào template EJS
  const templateData = {
    tableName: camelCaseTableName, // dùng camelCase cho tên file và biến
    capitalizedTableName: capitalizedTableName, // dùng Capitalize cho tên Model và hàm
    fields: fields,
    _: _, // Truyền lodash vào template để dùng
  };

  // 1. Sinh Model
  const modelTemplatePath = path.join(__dirname, 'templates', 'model.js.ejs');
  const modelCode = await ejs.renderFile(modelTemplatePath, templateData);
  fs.writeFileSync(path.join(modelDir, `${camelCaseTableName}.js`), modelCode);
  console.log(`Generated Model: ${modelDir}/${camelCaseTableName}.js`);

  // 2. Sinh Controller
  const controllerTemplatePath = path.join(__dirname, 'templates', 'controller.js.ejs');
  const controllerCode = await ejs.renderFile(controllerTemplatePath, templateData);
  fs.writeFileSync(path.join(controllerDir, `${camelCaseTableName}Controller.js`), controllerCode);
  console.log(`Generated Controller: ${controllerDir}/${camelCaseTableName}Controller.js`);

  // 3. Sinh Route
  const routeTemplatePath = path.join(__dirname, 'templates', 'route.js.ejs');
  const routeCode = await ejs.renderFile(routeTemplatePath, templateData);
  fs.writeFileSync(path.join(routesDir, `${camelCaseTableName}Routes.js`), routeCode);
  console.log(`Generated Route: ${routesDir}/${camelCaseTableName}Routes.js`);

  console.log(`\nCode generation completed for table: ${tableName}`);
  console.log(`Output directory: ${outputDir}`);
}

module.exports = { generateCode };
```

---

### Bước 4: Viết File Test (`test_generator.js`)

File này sẽ dùng để kiểm tra xem `generator.js` có hoạt động đúng không.

```javascript
const { generateCode } = require('./src/generator');

// Định nghĩa mẫu bảng đầu vào
const userTableDefinition = {
  tableName: 'User',
  fields: [
    { name: 'username', type: 'String', required: true, unique: true },
    { name: 'email', type: 'String', required: true, unique: true },
    { name: 'password', type: 'String', required: true },
    { name: 'age', type: 'Number', required: false },
    { name: 'isAdmin', type: 'Boolean', default: false },
    { name: 'createdAt', type: 'Date', default: 'Date.now' }, // Lưu ý: default là string, cần xử lý trong model
  ],
};

const productTableDefinition = {
  tableName: 'Product',
  fields: [
    { name: 'name', type: 'String', required: true },
    { name: 'price', type: 'Number', required: true },
    { name: 'description', type: 'String' },
    { name: 'category', type: 'String' },
    { name: 'stock', type: 'Number', default: 0 },
  ],
};

async function runTests() {
  console.log('--- Generating code for User table ---');
  await generateCode(userTableDefinition);

  console.log('\n--- Generating code for Product table ---');
  await generateCode(productTableDefinition);

  // Bạn có thể thêm các định nghĩa bảng khác để test
}

runTests().catch(console.error);
```

---

### Bước 5: Chạy thử Generator

1.  **Chắc chắn bạn đang ở thư mục gốc của dự án (`crud-generator-backend`).**
2.  **Chạy file test:**
    ```bash
    node test_generator.js
    ```

Sau khi chạy lệnh trên, bạn sẽ thấy các thông báo `Generated Model`, `Generated Controller`, `Generated Route` trong console. Đồng thời, một thư mục `generated_code` sẽ được tạo ra, chứa các thư mục con cho `user` và `product`, và bên trong mỗi thư mục đó sẽ có các file `models`, `controllers`, `routes` đã được sinh mã.

---

### Kết quả (Ví dụ về code sinh ra cho `user`)

**`generated_code/user/models/user.js`**

```javascript
const mongoose = require('mongoose');

const userSchema = new mongoose.Schema({
  username: {
    type: String,
    required: true,
    unique: true,
  },
  email: {
    type: String,
    required: true,
    unique: true,
  },
  password: {
    type: String,
    required: true,
  },
  age: {
    type: Number,
  },
  isAdmin: {
    type: Boolean,
  },
  createdAt: {
    type: Date,
  },
}, { timestamps: true });

module.exports = mongoose.model('User', userSchema);
```

**`generated_code/user/controllers/userController.js`**

```javascript
const User = require('../models/user');

// Lấy tất cả Users
exports.getAllUsers = async (req, res) => {
  try {
    const data = await User.find();
    res.status(200).json(data);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

// Lấy User theo ID
exports.getUserById = async (req, res) => {
  try {
    const data = await User.findById(req.params.id);
    if (!data) {
      return res.status(404).json({ message: 'User not found' });
    }
    res.status(200).json(data);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

// Tạo mới User
exports.createUser = async (req, res) => {
  const newData = new User(req.body);
  try {
    const savedData = await newData.save();
    res.status(201).json(savedData);
  } catch (error) {
    res.status(400).json({ message: error.message });
  }
};

// Cập nhật User
exports.updateUser = async (req, res) => {
  try {
    const updatedData = await User.findByIdAndUpdate(req.params.id, req.body, { new: true, runValidators: true });
    if (!updatedData) {
      return res.status(404).json({ message: 'User not found' });
    }
    res.status(200).json(updatedData);
  } catch (error) {
    res.status(400).json({ message: error.message });
  }
};

// Xóa User
exports.deleteUser = async (req, res) => {
  try {
    const data = await User.findByIdAndDelete(req.params.id);
    if (!data) {
      return res.status(404).json({ message: 'User not found' });
    }
    res.status(200).json({ message: 'User deleted successfully' });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};
```

**`generated_code/user/routes/userRoutes.js`**

```javascript
const express = require('express');
const router = express.Router();
const userController = require('../controllers/userController');

// Lấy tất cả
router.get('/', userController.getAllUsers);

// Lấy theo ID
router.get('/:id', userController.getUserById);

// Tạo mới
router.post('/', userController.createUser);

// Cập nhật
router.put('/:id', userController.updateUser);

// Xóa
router.delete('/:id', userController.deleteUser);

module.exports = router;
```

---

### Bước tiếp theo

Với các bước trên, bạn đã có một engine sinh mã cơ bản. Bước tiếp theo sẽ là tích hợp nó vào một API endpoint Express để frontend (Vue.js với Element Plus) có thể gọi tới để sinh mã.

Bạn muốn mình hướng dẫn tiếp cách tích hợp `generateCode` vào một ứng dụng Express không?